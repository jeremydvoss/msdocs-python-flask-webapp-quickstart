#load "kustoclusterinfo"
// *****PLEASE DO NOT MODIFY THIS PART*****
using Diagnostics.DataProviders;
using Diagnostics.ModelsAndUtils.Utilities;
using Diagnostics.ModelsAndUtils.Models;
using Diagnostics.ModelsAndUtils.Models.ResponseExtensions;
using Diagnostics.ModelsAndUtils.Attributes;
using Diagnostics.ModelsAndUtils.ScriptUtilities;
using Kusto.Data;
//*****END OF DO NOT MODIFY PART*****



using System;
using System.Linq;
using System.Data;
using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Text.RegularExpressions;
using System.Xml.Linq;
using Newtonsoft.Json;
using System.ComponentModel;
using System.Text;

private static string GetExtensionTrace(OperationContext<App> cxt)
{
    return
    $@"WebAppsAppInsightsExtensionLinux
    | where siteName =~ '{cxt.Resource.Name}'
    | order by ['time'] desc
    | limit 200
    | project ['time'], logger, message, msgId, language";
}

[AppFilter(AppType = AppType.WebApp | AppType.ApiApp, PlatformType = PlatformType.Linux, StackType = StackType.Python)]
[Definition(Id = "ApplicationInsightsLinuxAutoInstrumentationPython", Name = "Application Insights Python Auto Instrumentation - Linux", Author = "jeremyvoss", Category = Categories.ConfigurationAndManagement, Description = "This view provides information about Application Insights Auto Instrumentation")]
public async static Task<Response> Run(DataProviders dp, OperationContext<App> cxt, Response res)
{
    var subId = cxt.Resource.SubscriptionId;
    var rg = cxt.Resource.ResourceGroup;
    var name = cxt.Resource.Name;
    var slot = cxt.Resource.Slot;
    string descriptionText = string.Empty;
    List<ExtensionData> extensionTraceList = new List<ExtensionData>();
    string extensionTraceTableMarkdown = string.Empty;
    int statusInsight = (int)InsightStatus.Critical;

    try
    {
        DataTable aiTraceTable = null;

        IDictionary<string, string> appSettings = null;
        try {
            appSettings = await dp.GeoMaster.GetAppSettings(subId, rg, name, slot);
        }
        catch
        {
            appSettings = new Dictionary<string, string>();
        }

        try
        {
            aiTraceTable = await dp.Kusto.ExecuteQuery(GetExtensionTrace(cxt), cxt.Resource.Stamp.Name);
            if (aiTraceTable.Rows.Count == 0) {
                var leaderClusterName = await KustoClusterInfo.GetLeaderCluster(dp, cxt, GetExtensionTrace(cxt));
                aiTraceTable = await dp.Kusto.ExecuteClusterQuery(GetExtensionTrace(cxt), leaderClusterName, "wawsprod", null, "GetExtensionTrace");
            }
        }
        catch
        {
            // Handle failure in specific region due to table filters
            var leaderClusterName = await KustoClusterInfo.GetLeaderCluster(dp, cxt, GetExtensionTrace(cxt));
            aiTraceTable = await dp.Kusto.ExecuteClusterQuery(GetExtensionTrace(cxt), leaderClusterName, "wawsprod", null, "GetExtensionTrace");
        }

        if (aiTraceTable?.Rows?.Count > 0)
        {
            // Copy datatable output to list 
            foreach (DataRow dr in aiTraceTable.Rows)
            {
                ExtensionData extData = new ExtensionData
                {
                    TIMESTAMP = dr["time"].ToString(),
                    ProviderName = dr["logger"].ToString(),
                    Message = dr["message"].ToString().Replace("\n", "").Replace("\r", ""),
                    msgId = dr["msgId"].ToString(),
                    language = dr["language"].ToString(),
                };
                extensionTraceList.Add(extData);
            }

            // Select sigle set of data for validation.
            var indexList = extensionTraceList;

            if (indexList?.Count() > 0)
            {
                indexList.Reverse();  // After finding the actual data, reverse the order because query was ordered by time desc.
                AttachStatus attStatus = getAttachCoreStatus(indexList, appSettings);
                descriptionText = attStatus.descriptionText;
                extensionTraceTableMarkdown = attStatus.extensionTraceTableMarkdown;
                statusInsight = attStatus.statusInsight;
            }
            else
            {
                descriptionText = "This extension could not validate the data, please use data sources tab to execute the raw data.";
            }
        }
        else
        {
            descriptionText = "This Application is not instrumented with Codeless attach.";
        }
    }
    catch (Exception ex)
    {
        descriptionText = "This extension could not validate the data, An exception thrown during parse. " + ex.ToString();
    }

    descriptionText += Environment.NewLine + Environment.NewLine;

    string markDown = $"<markdown>{descriptionText} {Environment.NewLine} </markdown>";
    var insightDetails = new Dictionary<string, string>();
    insightDetails.Add("Status", markDown);
    var insight = new Insight((InsightStatus)statusInsight, "Application Insights Auto Instrumentation", insightDetails, true);
    res.AddInsight(insight);
    return res;
}

static AttachStatus getAttachCoreStatus(List<ExtensionData> extensionTraceList, IDictionary<string, string> appSettings)
{
    string description = string.Empty;
    int statInsight = (int)InsightStatus.Critical;
    string TraceTableMarkdown = string.Empty;

    string instrumentationKey = string.Empty;
    appSettings.TryGetValue("APPINSIGHTS_INSTRUMENTATIONKEY", out instrumentationKey);

    var extensionTraceTable = extensionTraceList.PropertiesToDataTable<ExtensionData>();
    TraceTableMarkdown = DataTableToMarkdown(extensionTraceTable);

    if (extensionTraceList.Where(x => x.msgId.Contains(SearchCoreCategory.ATTACH_SUCCESS_CONFIGURATOR)).Count() > 0)
    {
        description = String.Format(LogCategory.Success, instrumentationKey);
        statInsight = (int)InsightStatus.Success;
    }
    else if (extensionTraceList.Where(x => x.msgId.Contains(SearchCoreCategory.ATTACH_FAILURE_CONFIGURATOR)).Count() > 0)
    {
        description = String.Format(LogCategory.ConfiguratorFailed, instrumentationKey);
        statInsight = (int)InsightStatus.Error;
    }
    else if (extensionTraceList.Where(x => x.msgId.Contains(SearchCoreCategory.ATTACH_FAILURE_DISTRO)).Count() > 0)
    {
        description = String.Format(LogCategory.DistroFailed, instrumentationKey);
        statInsight = (int)InsightStatus.Error;
    }
    else
    {
        description = LogCategory.Error;
        statInsight = (int)InsightStatus.Warning;
    }

    // description += " Please refer to below table for more information.";

    return new AttachStatus()
    {
        descriptionText = description,
        statusInsight = statInsight,
        extensionTraceTableMarkdown = TraceTableMarkdown
    };
}

static string FindString(List<ExtensionData> extensionTraceList, string preText, string postText)
{
    var matches = extensionTraceList.Where(x => x.Message.Contains(preText));
    if (matches.Count() > 0)
    {
        string message = matches.First().Message;
        var startIndex = message.IndexOf(preText) + preText.Length;
        var endIndex = message.IndexOf(postText, startIndex);
        if (endIndex > startIndex)
        {
            return message.Substring(startIndex, endIndex - startIndex);
        }
    }
    return "Not Found";
}

class ExtensionData
{
    public string TIMESTAMP { get; set; }
    public string ProviderName { get; set; }
    public string Message { get; set; }
    public string msgId { get; set; }
    public string language { get; set;}
}

static DataTable PropertiesToDataTable<T>(this IEnumerable<T> source)
{
    DataTable dt = new DataTable();
    var props = TypeDescriptor.GetProperties(typeof(T));
    foreach (PropertyDescriptor prop in props)
    {
        DataColumn dc = dt.Columns.Add(prop.Name, prop.PropertyType);
        dc.Caption = prop.DisplayName;
        dc.ReadOnly = prop.IsReadOnly;
    }
    foreach (T item in source)
    {
        DataRow dr = dt.NewRow();
        foreach (PropertyDescriptor prop in props)
        {
            dr[prop.Name] = prop.GetValue(item);
        }
        dt.Rows.Add(dr);
    }
    return dt;
}

static string DataTableToMarkdown(DataTable dt)
{
    var markDownBuilder = new StringBuilder();
    List<string> columns = new List<string>();
    markDownBuilder.AppendLine(string.Join(" | ", dt.Columns.Cast<DataColumn>().Select(c => c.ColumnName)));
    string columnHeader = new StringBuilder().Insert(0, " --- |", dt.Columns.Count).ToString();
    columnHeader = columnHeader.Substring(1, columnHeader.Length - 1);
    markDownBuilder.AppendLine(columnHeader);
    foreach (DataRow dr in dt.Rows)
    {
        markDownBuilder.AppendLine(string.Join(" | ", dr.ItemArray));
    }
    return markDownBuilder.ToString();
}

public class LogCategory
{
    public static string Success = "Azure Monitor OpenTelemetry Auto-Instrumentation is successfully enabled and loaded for this webapp with ikey {0}.";
    public static string ConfiguratorFailed = "Azure Monitor OpenTelemetry Auto-Instrumentation failed to set up Configurator for this webapp with ikey {0}.";
    public static string DistroFailed = "Azure Monitor OpenTelemetry Auto-Instrumentation failed to set up Distro for this webapp with ikey {0}.";
    public static string Error = "Codeless agent has failed.";
    public static string NoAttach = "This Application is not instrumented with Codeless attach.";
}

public class SearchCoreCategory
{
    public static string ATTACH_SUCCESS_DISTRO = "4200";
    public static string ATTACH_SUCCESS_CONFIGURATOR = "4201";
    public static string ATTACH_FAILURE_DISTRO = "4400";
    public static string ATTACH_FAILURE_CONFIGURATOR = "4401";
}

class AttachStatus
{
    public string descriptionText { get; set; }
    public int statusInsight { get; set; }
    public string extensionTraceTableMarkdown { get; set; }
}
